# Sobre chamadas protegidas em Lua

Como é dito no [manual de Lua] (seção 2.3), quando interagimos com o estado de Lua sem estarmos dentro de uma função Lua, corremos o risco de um erro Lua ser levantado e nada ser feito.
O que Lua faz nessas situações é verificar se há uma função de pânico (ver `lua_atpanic`) e, caso sim, chamá-la.
Se uma função de pânico não tiver sido escolhida, o programa simplesmente aborta (ver `abort`).

Para que isso não aconteça precisamos proteger o nosso ambiente. Para isso serve a função `lua_pcall`, que chama uma função que está na pilha.
Ela retorna um valor inteiro que indica se houve erro e que tipo de erro ocorreu.
Caso houve erro, ela empilha a mensagem de erro (string).
Caso contrário, ela empilha o(s) valor(es) retornado(s) pela função.

Essa função é de fato o único "bote salva-vidas" que o programador de C tem de forma que seu programe não termine por problemas dos mais diversos.
Essa função é tão poderosa que até mesmo em casos de erros de alocação, é capaz de manter o programa estável e se "livrar" (temporariamente) do erro.

## Sobre a implementação de lua_error

Como é de conhecimento geral, Lua é implementada em ANSI C. O recurso mais utilizado para implementar exceções de tempo real são os chamados "pulos longos" (tradução literal de "long jumps").
Na biblioteca padrão de C, mais especificamente no cabeçalho [setjmp.h], duas funções orquestram o lançamento e tratamento dessas "exceções":

* `setjmp` determina o contexto que deve ser salvo
* `longjmp` pula para o contexto salvo

É possível, ainda, definir múltiplos contextos ao mesmo tempo. Para isso, o contexto é salvo em uma variável do tipo `jmp_buf`.
A implementação desse tipo é livre e pode inclusive não ter nenhuma informação significante interna (ver implementação da `glibc`).

Não é preciso ser um gênio da programação para saber que pulos longos podem ser perigosos, pois quebram o fluxo de controle do programa por completo, criando os famosos "buracos de minhoca" na linguagem popular.
No contexto de Python, isso pode ser perigosíssimo, pois estamos o tempo inteiro administrando a contagem de referência dos objetos e qualquer pulo longo no meio da execução do programa pode implicar em uma contagem de referência errada (pra mais ou para menos).

Existem duas soluções para esse problema:

## Solução #1 - Referências emprestadas

Do inglẽs "borrowed references", entendemos "emprestar" no sentido de não tomar posse de um objeto. No contexto de Python, isso significa não incrementar (nem decrementar) a contagem de referência de um objeto.
Fazemos isso quando temos certeza de que em outro lugar há alguém "tomando conta" desse objeto. É claro que se não houver nenhum objeto tomando conta, a contagem de referência desse objeto é 0 e ele será **imediatamente** coletado.

Se não estamos incrementando nem decrementando a contagem de referência de objetos em Python, não teremos o problema que acabamos de descrever (mas ainda teremos o problema no fluxo de controle).

## Solução #2 - Funções protegidas

Como era de se esperar, utilizaremos a função `lua_pcall` para nos protegermos do monstro do _long jump_. O que teremos que fazer agora é, ao invés de chamar alguma função potencialmente "pulante", e.g. `lua_gettable`, iremos chamá-la em modo protegido.
Fazemos isso empilhando primeiramente a função Lua (ou primeiro seus _upvalues_ e então empilhando a _closure_) e seus argumentos, e então chamando `lua_pcall`. Lidamos então em seguida com o esstado da chamada.
É interessante, ainda, termos alguma função padrão que envolve a função `lua_pcall` (um _wrapper_, em inglês), pois se estaremos optando por essa solução, chamaremos o tempo todo `lua_pcall` e teremos que desenvolver algum tratamento de erro padronizado.

## Vantagens e desvantagens de cada solução

A segunda solução pode ser mais lenta que a primeira pois envolve o _overhead_ de empilhar _upvalues_, a função, seus argumentos; desempilhar retornos.
No entanto, não há dúvidas que a segunda solução é mais segura e desejável em todos os outros sentidos que não performance.
A função de pânico não é desejável de se usar porque é literalmente a última opção antes do programa abortar. Veja só pelo nome: pânico. Não queremos nosso programa em pãnico, queremos?

### Desvantagens da Solução #1 em Cython

Ainda, num contexto de programação em _Cython_, a segunda é mais segura pois teremos o compilador do nosso lado ajudando-nos na tipagem dos tipos.
Isso porque _Cython_ cuida da contagem de referência dos nossos objetos automagicamente. Se quisermos que _Cython_ não "brinque" com a contagem de referência dos nossos objetos - essencialmente como referências emprestadas - precisamos explicitar o tipo como `PyObject*` (o tipo do objeto genérico de Python).
É claro que com esse tipo, _Cython_ não é capaz de realizar as otimizações que ele gostaria e que todos nós adoramos. Isso gera uma enorme desconfiança do _Cython_ com esses objetos.
É possível, é claro, assegurar que um objeto é de um determinado tipo (ver [manual de Cython]) usando a sintaxe `<MeuTipo?>` (que "pergunta" se o objeto após esse cast é do tipo `MeuTipo`).
No entanto, o código fica pesado com tantos casts que chega o momento que você se pergunta se realmente é a melhor solução (spoiler: provavelmente não).

[manual de Cython]: https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html
[manual de Lua]: https://www.lua.org/manual/5.4/manual.html#2.3
[setjmp.h]: https://en.wikipedia.org/wiki/Setjmp.h
