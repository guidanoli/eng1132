# Questions from "C APIs in extension and extensible languages"

Legend: "5.3p6-8" means "In section 5.3, paragraphs 6 to 8"

## How does Lupa manage calls from Python and Lua? (1p2)
## How does Lupa take advantage of Python and Lua dynamic natures? (1p4)
## Why are most scripting languages C APIs? (1p5)
## Why is Lupa implemented in Cython?

With Cython, it is easier to write somewhat version-agnostic code for Python extension modules.
But sometimes the incompatibility is so great that it must be explicitly handled (as with Python 2 versus Python 3).
Also, Cython code is much more maintainable than Python because it is more concise and abstracts the C API.
Still, you can call C API functions if you really need to.
Because the compiler is good at generating efficient C code, it can often lead to performance gains over writing pure C code.
Another big advantage of writing in Cython is that you don't have to worry about the burden of reference counting for Python objects.
It automatically generates calls to the C API related to reference counting where necessary. This can be turned of by typing objects with `PyObject*` instead of `object`.

## Could C be the extension language in both usages of Lupa, while Lua and Python are the extensible languages? (2p4)
## Compare how embeddable and the extensibile Python and Lua are. (2p5)

It can be seen for several aspects that Python is not optimized for being embedded in applications.
For instance, altough the Python environment is structured in modules in order to avoids namespace conflicts,
it makes storing variables in the global scope harder, since there is no single global scope. (5p2-3)

Furthermore, for the reasons previously provided, when evaluating an expression through the Python C API,
one has to provide both the local and global scopes (which effectively dictionaries) of the current execution frame.
Such concept of execution frames is implicit in the Lua C API, and one can call `lua_load` for the same purpose,
while not having to specify the scope, making it prefferable for embedding.

## How memory management differ from Python and Lua? (3p2)

(Could we traverse `_LuaObject` in order to resolve the cyclic reference problem?)

## How data are transfered between Python and Lua? (3.1p1-2)

### Parameters

(Mention keyword arguments in Python and named parameters in Lua)

### Object attributes

(Mention `as_attrgetter` and `as_itemgetter` and the reason for these protocols in terms of the semantics of each language)

### Converting or wrapping objects (3.1p2)

#### Integer overflow handling

(Mention Python and Lua integer types, and why the problem is unidirectional)

#### `nil` and `python.none`

(Mention the semantics of `nil` in Lua in tables, function parameters and iterators)

#### String encoding

(Look into it)

#### Opaque object types

(Talk about `_LuaObject` in Python and `userdata` in Lua and they metamethods, constructors and finalizers)

#### Large strings should be wrapped?

(Look into it)

## How are concurrent threads handled in Lupa? (3.1p3)

(Look into coroutines)

## Discuss the reference cycle problem.

**Brief:**

One language can't see the full picture.
This is resolved when one of the languages is finalized first.
If the host is Python, Lua is finalized first (and vice versa).

## How is the Python interpreter initialized and finalized when Lupa is loaded from Lua? (2.3p2)

**Brief:**

When Lupa is loaded from Lua, the Python interpreter is initialized (`Py_InitializeEx`) and dynamically opened if on Linux (`dlopen`).
A table is registered in the registry to be collected when the Lua state is closed.
This table has a `gc` metamethod that finalizes the Python interpreter and closes the library if it were dynamically opened.

## How is the Lua state initialized and finalized when Lupa is loaded from Python? (2.3p2)

**Brief:**

When a `LuaRuntime` instance is constructed, a Lua state is created.
Its `__dealloc__` method then closes the Lua state.

## Why would a Lua developer want to have an interface with Python? (4p2)

**Brief:**

"Python has a more complete feature set than Lua" (excerpt from the article)

It is a fact that Python has a much richer standard library.
Therefore, it can serve then as an "all-in-one" solution for a vast range of problems.

## How do Lua and Python distinct C API natures influence the code for Lupa? (4.1p1-2)

While Python always signalizes errors with return values of function calls, Lua errors are implemented as long jumps.
When an error is raised in a protected context, Lua redirects the program flow to an established "check point" (see `lua_pcall`).
On the other hand, calling Lua API functions in an unprotected environment causes Lua to panic (see `lua_atpanic`).
This creates a major problem for Lupa, because in both cases, long jumps would kill the reference counting of Python objects.
Altough Cython manages reference counting automatically, it never expects program flow to be redirected non-locally.
Hence, in order to tell Cython not to interact with the Python C API in specific functions, we use the `nogil` attribute.
We then call these C functions in protected mode with `lua_pcall`.

(Give as examples `lua_gettable` and `lua_objlen` for Lua 5.1 or `luaL_len` for Lua > 5.1)

We also need to guarantee the consistency of the Lua stack when Python exceptions are raised.
In Python, the `try-except` construct is used to properly handle exceptions.
When an exception is raised inside a `try` block, the program flow is redirected to the appropriate `except` block.
Furthermore, a `finally` block can be added to be executed at the end whether an exception is raised or not.
So, in order to "restore" the Lua context when a Python exception is raised,
we store the stack top before entering the `try` block (`lua_gettop`), and reset it in the `finally` block (`lua_settop`).
