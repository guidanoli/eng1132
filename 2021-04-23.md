# Questions from "C APIs in extension and extensible languages"

Legend: "5.3p6-8" means "In section 5.3, paragraphs 6 to 8"

## How does Lupa manage calls from Python and Lua? (1p2)

When a Lua object is called in Python, its triggers its `__call__` method, which only accepts positional arguments,
since keyword arguments are not supported in Lua. Each argument is then converted and pushed onto the Lua stack.
A specific error handler is also pushed onto the stack to allow a stack traceback to be generated on errors.
The call is executed in protected mode and the return values are converted back to Python and returned back to `__call__`.

For calling Python objects in Lua, the `__call` metamethod is triggered. The userdatum and arguments in the stack are
converted to Python objects and the call is executed in a try-except block in case any Python exception is raised.
Although it may seem similar to the previous case, calling Python objects in Lua exposes some interesting differences between the two languages.

* Python methods are bound to objects, while Lua methods aren't.
* Python function calls accept keyword arguments, while Lua functions don't.

First, we need to address the problem with Python methods.
In simple terms, we would like to translate the following Lua code:

```lua
pyobj:method(...)  # which is pyobj.method(pyobj, ...)
```

... into the following Python code:

```python
pyobj.method(...)  # which is type(pyobj).method(pyobj, ...)
```

We then need to check if `pyobj` and the first argument are equal and if the method is bound to `pyobj`.
In that case, we simply convert the method into a function (thus, making it not bound anymore).

We also need to find a way to call Python objects with keyword arguments in Lua.
The solution we came up with envolves allowing the user to construct a userdatum containing positional and keyword arguments
which would be "unpacked" if passed to a Python object call. The function that allows constructing this object takes a
Lua table as argument, employing the following heuristic.

* The sequential part of the Lua table (where the keys are integers from 1 to the length of the table) maps to the positional arguments in Python
* The record-like part of the Lua table (where keys are strings) maps to keyword arguments in Python
* Any key that does not fit in any of the previous two criterium is invalid (unpacking would raise an error)

An interesting consequence of this heuristic is that non-sequential integer keys are considered invalid. For example

```lua
python.builtins.print(python.args{1, 2, 3}) # 1, 2, 3 -- ok
python.builtins.print(python.args{1, 2, 3, [7] = 5}) # error
```

Moreover, these argument objects can be combined within the same call to allow the following use case.

```lua
A = python.args{5, 7, end=''}
B = python.args{11, sep=', '}
C = python.args{9}

python.builtins.print(A, B) # -> 5, 7, 11
python.builtins.print(B, C) # -> 11, 9
```

See https://github.com/scoder/lupa/pull/177 for the development of this feature.

## How does Lupa take advantage of Python and Lua dynamic natures? (1p4)
## Why are most scripting languages C APIs? (1p5)
## Why is Lupa implemented in Cython?

With Cython, it is easier to write somewhat version-agnostic code for Python extension modules.
But sometimes the incompatibility is so great that it must be explicitly handled (as with Python 2 versus Python 3).
Also, Cython code is much more maintainable than Python because it is more concise and abstracts the C API.
Still, you can call C API functions if you really need to.
Because the compiler is good at generating efficient C code, it can often lead to performance gains over writing pure C code.
Another big advantage of writing in Cython is that you don't have to worry about the burden of reference counting for Python objects.
It automatically generates calls to the C API related to reference counting where necessary. This can be turned of by typing objects with `PyObject*` instead of `object`.

## Could C be the extension language in both usages of Lupa, while Lua and Python are the extensible languages? (2p4)
## Compare how embeddable and extensibile Python and Lua are. (2p5)

It can be seen for several aspects that Python is not optimized for being embedded in applications.
For instance, because the Python environment is structured in modules in order to avoids namespace conflicts,
storing variables in a global scope is harder than in Lua, since there is no single global scope. (5p2-3)
Furthermore, evaluating expressions through the Python C API requires defining a global and a local scope,
while in Lua you can evaluate expressions from strings and files anywhere in the code, which makes it prefferable
for embedding. One can say that Lua is prefferable for embedded systems for its smaller footprint, compared to Python.
Also, for machines with less computing power, Lua generally outruns Python in benchmarks. (needs source)

On the other hand, many of the cited aspects about Python can be seen as strengths, rather than weaknesses.
Having the environment structured in modules helps ever-growing software to take shape and extend the already
rich feature set of the Python standard library. Moreover, Python has built-in functionalities for installing,
setting up and testing extensions. It goes without saying that the standardization of these processes aids the
integration of libraries and other ressources.

As for Lua, there is no standardized form for sharing libraries, although LuaRocks is a well known (unofficial)
Lua package manager. Nevertheless, the Lua API is as optimal for embedding as for extending,
since it is orthogonal to its use. There are no specific core API functions for registering modules because
they are generally just tables with functions. Apart from elegant, the minimalist nature of Lua is also
responsible for making its API symmetrical from both the host program and the add-on module points of view.

## How memory management differ from Python and Lua? (3p2)

(Could we traverse `_LuaObject` in order to resolve the cyclic reference problem?)

## How data are transfered between Python and Lua? (3.1p1-2)

### Parameters

(Mention keyword arguments in Python and named parameters in Lua)

### Object attributes

(Mention `as_attrgetter` and `as_itemgetter` and the reason for these protocols in terms of the semantics of each language)

### Converting or wrapping objects (3.1p2)

#### Integer overflow handling

(Mention Python and Lua integer types, and why the problem is unidirectional)

#### `nil` and `python.none`

(Mention the semantics of `nil` in Lua in tables, function parameters and iterators)

#### String encoding

(Look into it)

#### Opaque object types

(Talk about `_LuaObject` in Python and `userdata` in Lua and they metamethods, constructors and finalizers)

#### Large strings should be wrapped?

(Look into it)

## How are concurrent threads handled in Lupa? (3.1p3, 5p13)

(Look into coroutines)

## Discuss the reference cycle problem.

**Brief:**

One language can't see the full picture.
This is resolved when one of the languages is finalized first.
If the host is Python, Lua is finalized first (and vice versa).

## How is the Python interpreter initialized and finalized when Lupa is loaded from Lua? (2.3p2)

**Brief:**

When Lupa is loaded from Lua, the Python interpreter is initialized (`Py_InitializeEx`) and dynamically opened if on Linux (`dlopen`).
A table is registered in the registry to be collected when the Lua state is closed.
This table has a `gc` metamethod that finalizes the Python interpreter and closes the library if it was dynamically opened.

## How is the Lua state initialized and finalized when Lupa is loaded from Python? (2.3p2)

**Brief:**

When a `LuaRuntime` instance is constructed, a Lua state is created.
Its `__dealloc__` method then closes the Lua state.

## Why would a Lua developer want to have an interface with Python? (4p2)

**Brief:**

"Python has a more complete feature set than Lua" (excerpt from the article)

It is a fact that Python has a much richer standard library.
Therefore, it can serve then as an "all-in-one" solution for a vast range of problems.

## How do Lua and Python distinct C API natures influence the code for Lupa? (4.1p1-2)

While Python always signalizes errors with return values of function calls, Lua errors are implemented as long jumps.
When an error is raised in a protected context, Lua redirects the program flow to an established "check point" (see `lua_pcall`).
On the other hand, calling Lua API functions in an unprotected environment causes Lua to panic (see `lua_atpanic`).
This creates a major problem for Lupa, because in both cases, long jumps would kill the reference counting of Python objects.
Altough Cython manages reference counting automatically, it never expects program flow to be redirected non-locally.
Hence, in order to tell Cython not to interact with the Python C API in specific functions, we use the `nogil` attribute.
We then call these C functions in protected mode with `lua_pcall`.

(Give as examples `lua_gettable` and `lua_objlen` for Lua 5.1 or `luaL_len` for Lua > 5.1)

We also need to guarantee the consistency of the Lua stack when Python exceptions are raised.
In Python, the `try-except` construct is used to properly handle exceptions.
When an exception is raised inside a `try` block, the program flow is redirected to the appropriate `except` block.
Furthermore, a `finally` block can be added to be executed at the end whether an exception is raised or not.
So, in order to "restore" the Lua context when a Python exception is raised,
we store the stack top before entering the `try` block (`lua_gettop`), and reset it in the `finally` block (`lua_settop`).

## How well documented are the Python and Lua and their respective APIs?  (5p7)

Both languages and their APIs are relly well documented.
Not only that, the source code of both languages are very much readable.

## Where does Lupa come from? (5p13)

It is a partial rewrite from Lunatic Python, a project by Gustavo Niemeyer.
It has been inactive for quite a long time (for more than 13 years).
It is incompatible with current versions of Python and Lua for that reason.
Lunatic Python had also other forks too, such as one by [bastibe](https://github.com/bastibe/lunatic-python).
Lupa is very distinct because it is implemented in Cython and can only be loaded as a Python extension module.
It has added plenty of features not present in the original project and extensive tests.
It is mainly maintained by Stefan Behnel, one of the main maintainers of Cython too.
This choice of language is really optimal since Python is really mainly meant for extending rather than embedding.
Also, it is hard to implement such a big extension module with the ever-changing Python C API.
To solve this issue, Cython adds an abstraction layer so that the developer can mainly write Python-like code.
It can, of course, make calls to Python C API functions if they really need to.
